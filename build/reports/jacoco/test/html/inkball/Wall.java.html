<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Wall.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">INKBALL</a> &gt; <a href="index.source.html" class="el_package">inkball</a> &gt; <span class="el_source">Wall.java</span></div><h1>Wall.java</h1><pre class="source lang-java linenums"> package inkball;

public class Wall {
    private int x, y;
    private char wallType; // X for regular, '1' to '4' for colored walls
    String newColor;

<span class="fc" id="L8">    public Wall(int x, int y, char wallType) {</span>
<span class="fc" id="L9">        this.x = x;</span>
<span class="fc" id="L10">        this.y = y;</span>
<span class="fc" id="L11">        this.wallType = wallType;</span>
<span class="fc" id="L12">    }</span>

    public char getWallType() {
<span class="fc" id="L15">        return wallType;</span>
    }

    public int getX() {
<span class="fc" id="L19">        return x;</span>
    }

    public int getY() {
<span class="fc" id="L23">        return y;</span>
    }

    // Calculate the ball center
    private float calculateBallCenterX(Ball ball) {
<span class="fc" id="L28">        return ball.getX() + ball.getRadius();</span>
    }

    private float calculateBallCenterY(Ball ball) {
<span class="fc" id="L32">        return ball.getY() + ball.getRadius();</span>
    }

    // Collision detection method
    public boolean isOverlapping(Ball ball) {
<span class="fc" id="L37">        float ballCenterX = calculateBallCenterX(ball);</span>
<span class="fc" id="L38">        float ballCenterY = calculateBallCenterY(ball);</span>
<span class="fc" id="L39">        int ballRadius = ball.getRadius();</span>

        // Wall coordinates
<span class="fc" id="L42">        int wallLeft = x * App.CELLSIZE;</span>
<span class="fc" id="L43">        int wallRight = wallLeft + App.CELLSIZE;</span>
<span class="fc" id="L44">        int wallTop = y * App.CELLHEIGHT;</span>
<span class="fc" id="L45">        int wallBottom = wallTop + App.CELLHEIGHT;</span>

        // Check for overlap (AABB collision detection)
<span class="fc bfc" id="L48" title="All 8 branches covered.">        boolean overlap = ballCenterX + ballRadius &gt; wallLeft &amp;&amp; ballCenterX - ballRadius &lt; wallRight &amp;&amp;</span>
                          ballCenterY + ballRadius &gt; wallTop &amp;&amp; ballCenterY - ballRadius &lt; wallBottom;

<span class="fc" id="L51">        return overlap;</span>
    }

<span class="fc" id="L54">    private int collisionBuffer = 0; // Add a buffer to handle repeated collisions</span>

public void handleCollision(Ball ball) {
<span class="fc bfc" id="L57" title="All 2 branches covered.">    if (!isOverlapping(ball)) return;  // No collision detected</span>

<span class="fc" id="L59">    float ballCenterX = calculateBallCenterX(ball);  // Get ball's center</span>
<span class="fc" id="L60">    float ballCenterY = calculateBallCenterY(ball);</span>
<span class="fc" id="L61">    int ballRadius = ball.getRadius();</span>

    // Wall boundaries (assumed to be rectangular grid cells)
<span class="fc" id="L64">    int wallLeft = x * App.CELLSIZE;</span>
<span class="fc" id="L65">    int wallRight = wallLeft + App.CELLSIZE;</span>
<span class="fc" id="L66">    int wallTop = y * App.CELLHEIGHT;</span>
<span class="fc" id="L67">    int wallBottom = wallTop + App.CELLHEIGHT;</span>

    // Calculate distances from ball edge to the wall edges
<span class="fc" id="L70">    float distToLeft = (ballCenterX - ballRadius) - wallLeft;</span>
<span class="fc" id="L71">    float distToRight = wallRight - (ballCenterX + ballRadius);</span>
<span class="fc" id="L72">    float distToTop = (ballCenterY - ballRadius) - wallTop;</span>
<span class="fc" id="L73">    float distToBottom = wallBottom - (ballCenterY + ballRadius);</span>

    // Find the closest side by checking the smallest distance
<span class="fc" id="L76">    float minDistance = Math.min(Math.min(distToLeft, distToRight), Math.min(distToTop, distToBottom));</span>

    // Reflect the ball based on the closest side and adjust its position
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">    if (minDistance == distToLeft) {</span>
        // Ball hit the left side of the wall, reverse X direction
<span class="nc" id="L81">        ball.reverseHorizontalDirection();</span>
<span class="nc" id="L82">        ball.setX(wallLeft - 2 * ballRadius);  // Move ball just outside the left wall boundary</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">    } else if (minDistance == distToRight) {</span>
        // Ball hit the right side of the wall, reverse X direction
<span class="nc" id="L85">        ball.reverseHorizontalDirection();</span>
<span class="nc" id="L86">        ball.setX(wallRight);  // Move ball just outside the right wall boundary</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">    } else if (minDistance == distToTop) {</span>
        // Ball hit the top side of the wall, reverse Y direction
<span class="fc" id="L89">        ball.reverseVerticalDirection();</span>
<span class="fc" id="L90">        ball.setY(wallTop - 2 * ballRadius);  // Move ball just outside the top wall boundary</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">    } else if (minDistance == distToBottom) {</span>
        // Ball hit the bottom side of the wall, reverse Y direction
<span class="nc" id="L93">        ball.reverseVerticalDirection();</span>
<span class="nc" id="L94">        ball.setY(wallBottom);  // Move ball just outside the bottom wall boundary</span>
    }

    // Handle color change for colored walls
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">    if (Character.isDigit(wallType)) {</span>
<span class="nc" id="L99">        String newColor = getWallColor(wallType);</span>
<span class="nc" id="L100">        ball.setColor(newColor);</span>
    }
<span class="fc" id="L102">}</span>


    public String getWallColor(char wallTile) {
<span class="pc bpc" id="L106" title="5 of 6 branches missed.">        switch (wallTile) {</span>
<span class="fc" id="L107">            case 'X': return &quot;grey&quot;;</span>
<span class="nc" id="L108">            case '1': return &quot;orange&quot;;</span>
<span class="nc" id="L109">            case '2': return &quot;blue&quot;;</span>
<span class="nc" id="L110">            case '3': return &quot;green&quot;;</span>
<span class="nc" id="L111">            case '4': return &quot;yellow&quot;;</span>
<span class="nc" id="L112">            default: return &quot;grey&quot;;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>